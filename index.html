<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dynamic Organization Chart</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --header-height: 70px;
        }
        
        html {
            /* Prevent browser zoom */
            -ms-content-zooming: none;
            -ms-touch-action: none;
            touch-action: none;
            overflow: hidden;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            overflow: hidden;
            /* Prevent text selection during drag */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            transform: none !important;
            /* Prevent browser zoom */
            touch-action: none;
            -ms-touch-action: none;
        }
        
        /* Header */
        header { 
            position: fixed;
            top: 0; 
            left: 0; 
            right: 0; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 40px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.15); 
            z-index: 10000; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            height: var(--header-height);
            transform: none !important;
            transform-origin: initial !important;
            will-change: auto;
            isolation: isolate;
            contain: layout style paint;
        }
        
        h2 { 
            margin: 0; 
            color: #ffffff; 
            font-size: 24px; 
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: 40px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 25px;
        }
        
        .search-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        #search-input {
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 14px;
            min-width: 220px;
            transition: all 0.3s ease;
        }
        
        #search-input::placeholder {
            color: rgba(255,255,255,0.7);
        }
        
        #search-input:focus {
            outline: none;
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
        }
        
        .btn-search {
            background: rgba(59, 130, 246, 0.4);
            color: white;
            border: 1px solid rgba(59, 130, 246, 0.6);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
        
        .btn-search:hover {
            background: rgba(59, 130, 246, 0.5);
            transform: translateY(-2px);
        }
        
        .controls {
            display: flex;
            gap: 10px;
        }
        
        .zoom-hint {
            position: fixed;
            top: calc(var(--header-height) + 30px);
            right: 40px;
            background: rgba(255,255,255,0.9);
            color: #667eea;
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 9999;
            white-space: nowrap;
        }
        
        .zoom-hint kbd {
            background: rgba(102, 126, 234, 0.15);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 700;
            font-family: monospace;
            color: #667eea;
        }
        
        .btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            /* Allow text selection in buttons */
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
        
        .btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .btn-refresh {
            background: rgba(34, 197, 94, 0.3);
            border-color: rgba(34, 197, 94, 0.5);
        }
        
        .btn-refresh:hover {
            background: rgba(34, 197, 94, 0.4);
        }

        /* Chart Area */
        #chart { 
            width: 100%; 
            height: 100vh;
            padding-top: var(--header-height);
            background: radial-gradient(circle at 50% 50%, #ffffff 1px, transparent 1px) 0 0 / 30px 30px,
                        radial-gradient(circle at 50% 50%, #f0f0f0 1px, transparent 1px) 15px 15px / 30px 30px;
            overflow: hidden;
            /* Add grab cursor for the chart area */
            cursor: grab;
            /* Prevent browser native zoom/pinch gestures */
            touch-action: none;
        }

        /* SVG specific cursor handling */
        #chart svg {
            cursor: grab;
            touch-action: none;
        }
        
        #chart svg:active {
            cursor: grabbing;
        }

        /* Node Styling - CARD BASED */
        .node {
            cursor: pointer;
        }
        
        .node rect { 
            fill: #ffffff;
            stroke: #667eea;
            stroke-width: 2px;
            transition: all 0.3s ease;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
            rx: 8;
            ry: 8;
        }
        
        .node.has-children rect {
            fill: #fef3c7;
        }
        
        .node:hover rect { 
            stroke: #764ba2;
            stroke-width: 3px;
            filter: drop-shadow(0 4px 8px rgba(102, 126, 234, 0.3));
        }
        
        .node text { 
            font-size: 11px;
            font-weight: 500;
            fill: #1f2937;
            pointer-events: none;
            user-select: none;
        }
        
        .node-name {
            font-size: 14px !important;
            font-weight: 700 !important;
            fill: #111827 !important;
        }
        
        .node-label {
            font-size: 10px !important;
            fill: #6b7280 !important;
            font-weight: 600 !important;
        }
        
        .node-value {
            font-size: 10px !important;
            fill: #374151 !important;
        }

        /* Link Styling */
        .link { 
            fill: none; 
            stroke: #475569; 
            stroke-width: 2px;
            opacity: 0.6;
            transition: all 0.3s ease;
        }

        /* Collapsed indicator */
        .node.collapsed rect {
            fill: #fef3c7;
            stroke: #f59e0b;
            stroke-width: 3px;
        }
        
        /* Highlight searched node */
        .node.highlighted rect {
            fill: #dbeafe;
            stroke: #3b82f6;
            stroke-width: 3px;
            animation: pulse 2s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { 
                stroke: #3b82f6;
                filter: drop-shadow(0 0 10px rgba(59, 130, 246, 0.5));
            }
            50% { 
                stroke: #1d4ed8;
                filter: drop-shadow(0 0 20px rgba(59, 130, 246, 0.8));
            }
        }
        
        /* Count badge for collapsed nodes */
        .count-badge {
            font-size: 11px;
            font-weight: bold;
            fill: #ffffff;
            pointer-events: none;
            user-select: none;
        }
        
        .count-badge-bg {
            fill: #ef4444;
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            opacity: 0;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border: 2px solid #667eea;
            box-shadow: 0 15px 40px -5px rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 0;
            pointer-events: auto;
            min-width: 280px;
            max-width: 350px;
            z-index: 1000;
            transition: opacity 0.2s ease;
            /* Allow text selection in tooltip */
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
        
        .tooltip-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 20px;
            border-radius: 13px 13px 0 0;
        }
        
        .tooltip-header h4 { 
            margin: 0 0 5px 0; 
            font-size: 18px; 
            color: #ffffff;
            font-weight: 700;
        }
        
        .tooltip-header .subtitle {
            font-size: 13px;
            color: rgba(255,255,255,0.8);
            margin: 0;
        }
        
        .tooltip-body {
            padding: 15px 20px;
        }
        
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f3f4f6;
            font-size: 14px;
        }
        
        .tooltip-row:last-child {
            border-bottom: none;
        }
        
        .tooltip-label {
            color: #6b7280;
            font-weight: 500;
        }
        
        .tooltip-value {
            color: #1f2937;
            font-weight: 600;
            text-align: right;
        }

        /* Loading indicator */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px 50px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 200;
        }
        
        .loading-text {
            font-size: 18px;
            color: #667eea;
            font-weight: 600;
        }
    </style>
</head>
<body>

<header>
    <h2>
        <span style="font-size: 28px;">üè¢</span>
        <span>Organization Chart</span>
    </h2>
    <div class="header-right">
        <div class="search-container">
            <input type="text" id="search-input" placeholder="Search employee name..." />
            <button class="btn-search" onclick="searchEmployee()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 5px;">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                </svg>
                Search
            </button>
        </div>
        <div class="controls">
            <button class="btn btn-refresh" onclick="manualRefresh()">üîÑ Refresh Data</button>
            <button class="btn" onclick="collapseAll()">Collapse All (C)</button>
            <button class="btn" onclick="resetZoom()">Reset View (R)</button>
        </div>
    </div>
</header>

<div class="zoom-hint">
    Use <kbd>-</kbd> / <kbd>+</kbd> to zoom
</div>

<div id="chart"></div>
<div id="tooltip" class="tooltip"></div>
<div id="loading" class="loading" style="display: none;">
    <div class="loading-text">Loading organization data...</div>
</div>

<script>
// =======================================================
// CONFIGURATION
// =======================================================

const SHEET_ID = "1lemebG36uQ9MlbKZC_O2H_ltJZZI8aXFlnWlMbD4MXA"; // Replace with your Google Sheet ID
const SHEET_NAME = "Admin_Sheet"; // Replace with your sheet name

const SHEET_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${SHEET_NAME}`;

// Top-level whitelist - employees in this list will appear at top level regardless of their manager
const TOP_LEVEL_WHITELIST = [
    "Kanishka Tongya",
    "Jagmeet Singh",
    "SP Yadav"
];

// Employees in these departments will be completely hidden
const DEPT_BLACKLIST = [
    "Third Party Installer",
    "Operations- Installer Dedicated",
    "Operations- Installer Non-Dedicated",
    "Operations- Installer",
    "Test-Department-prime-Chat",
    "Testing_department"
];
    
// Chart dimensions
const HEADER_HEIGHT = 70; // Must match --header-height in CSS
const width = window.innerWidth;
const height = window.innerHeight - HEADER_HEIGHT;
const nodeWidth = 255;  // 280 * 0.85 + 17 = 255
const nodeHeight = 127.5;  // 150 * 0.85 = 127.5
const verticalSpacing = 180;
const horizontalSpacing = 300;

// Grade order for sorting children
const gradeOrder = ['T-2', 'T-1', 'P-4', 'P-3', 'P-2', 'P-1', 'D-3', 'D-2', 'D-1', 
                    'S-3', 'S-2', 'S-1', 'M-3', 'M-2', 'M-1', 'E-3', 'E-2', 'E-1', 'I'];

// Function to normalize grade (remove A/B suffix)
function normalizeGrade(grade) {
    if (!grade) return 'UNKNOWN';
    return grade.toString().replace(/[AB]$/i, '').trim();
}

// Function to get grade order index
function getGradeIndex(grade) {
    const normalized = normalizeGrade(grade);
    const index = gradeOrder.indexOf(normalized);
    return index === -1 ? 999 : index; // Unknown grades go to the end
}

// Global variables
let root;
let svg, g, tree, zoom;
let tooltip;
let currentTransform = null; // Track current zoom/pan state
let isDragging = false;

// =======================================================
// INITIALIZE
// =======================================================
function initialize() {
    // Prevent browser zoom on chart area specifically
    const chartDiv = document.getElementById('chart');
    chartDiv.addEventListener('wheel', function(e) {
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            e.stopPropagation();
        }
    }, { passive: false, capture: true });
    
    // Create SVG
    svg = d3.select("#chart").append("svg")
        .attr("width", "100%")
        .attr("height", height)
        .style("display", "block");
    
    // Create zoom behavior with improved settings
    zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .filter(event => {
            // Allow zoom with wheel, but prevent it on buttons/controls
            if (event.type === 'wheel') return true;
            if (event.type === 'dblclick') return true;
            
            // Only allow drag with left mouse button
            if (event.type === 'mousedown') return event.button === 0;
            
            return !event.button;
        })
        .on("start", function(event) {
            // Change cursor to grabbing when dragging starts
            d3.select("#chart").style("cursor", "grabbing");
            isDragging = true;
        })
        .on("zoom", (event) => {
            g.attr("transform", event.transform);
            currentTransform = event.transform; // Save current state
        })
        .on("end", function(event) {
            // Reset cursor after dragging ends
            setTimeout(() => {
                if (!isDragging) {
                    d3.select("#chart").style("cursor", "grab");
                }
            }, 50);
            isDragging = false;
        });
    
    svg.call(zoom);
    
    // Create main group
    g = svg.append("g")
        .attr("transform", `translate(${width / 2}, 50)`);
    
    // Create tree layout
    tree = d3.tree()
        .nodeSize([horizontalSpacing, verticalSpacing])
        .separation((a, b) => (a.parent === b.parent ? 1 : 1.2));
    
    // Add event listener to reset cursor when mouse leaves chart area
    d3.select("#chart").on("mouseleave", function() {
        d3.select("#chart").style("cursor", "grab");
        isDragging = false;
    });
    
    // Load data
    loadAndRenderData();
}

// =======================================================
// DATA LOADING
// =======================================================
function loadAndRenderData() {
    document.getElementById('loading').style.display = 'block';
    
    d3.csv(SHEET_URL).then(data => {
        console.log("Data loaded:", data.length, "records");
        
        // Build hierarchy
        const hierarchyData = buildHierarchy(data);
        
        // Create root
        root = d3.hierarchy(hierarchyData);
        
        // Collapse all children first
        root.children.forEach(collapse);
        
        // Then collapse the root itself so nothing shows on initial load
        collapse(root);
        
        // Render
        update(root);

        // --- ADD LOGO ABOVE LEVEL 0 ---
        const logoWidth = 300;
        const logoHeight = 150;
        const logoGroup = g.append("g")
            .attr("class", "logo-group")
            .style("cursor", "pointer")
            .on("click", () => {
                toggle(root);
                update(root);
            });
        
        logoGroup.append("image")
            .attr("xlink:href", "logo.png")
            .attr("width", logoWidth)
            .attr("height", logoHeight)
            .attr("x", root.x - (logoWidth / 2)) 
            .attr("y", root.y - (logoHeight / 3));
        // ------------------------------
        
        // Center on root
        centerNode(root);
        
        document.getElementById('loading').style.display = 'none';
        
        // Reset cursor after loading
        d3.select("#chart").style("cursor", "grab");
        
    }).catch(error => {
        console.error("Error loading data:", error);
        document.getElementById('loading').style.display = 'none';
        alert("Error loading data from Google Sheets. Check console for details.");
    });
}

// Manual refresh function
function manualRefresh() {
    // Clear existing chart
    d3.select("#chart svg").remove();
    
    // Reset cursor
    d3.select("#chart").style("cursor", "default");
    
    // Recreate SVG structure
    svg = d3.select("#chart").append("svg")
        .attr("width", "100%")
        .attr("height", height)
        .style("display", "block");
    
    svg.call(zoom);
    
    g = svg.append("g")
        .attr("transform", `translate(${width / 2}, 50)`);
    
    // Reset transform tracking
    currentTransform = null;
    
    // Load fresh data
    loadAndRenderData();
}

// =======================================================
// BUILD HIERARCHY
// =======================================================
function buildHierarchy(data) {
    // First pass: Create empid-to-id and name-to-employee mapping
    const empidToId = new Map();
    const nameToEmployees = new Map(); // Store array of employees with same name
    
    data.forEach(row => {
        const name = row.Name ? row.Name.trim() : "";
        const id = row.Id ? row.Id.toString().trim() : "";
        const empid = row.Empid ? row.Empid.trim() : "";
        const remark = row.Remark ? row.Remark.trim() : "";
        const department = row["Department Name"] ? row["Department Name"].trim() : ""; // Extract department here
        
        // Skip employees with Remark = "No"
        if (remark.toLowerCase() === "no") {
            return;
        }

        // NEW: Skip employees in Blacklisted Departments
        if (DEPT_BLACKLIST.includes(department)) {
            return;
        }
        
        if (name && id && empid) {
            empidToId.set(empid, id);
            
            // Handle duplicate names by storing arrays
            if (!nameToEmployees.has(name)) {
                nameToEmployees.set(name, []);
            }
            nameToEmployees.get(name).push({ id, empid, name });
        }
    });
    
    // Second pass: Create employee map using ID as key
    const employeeMap = new Map();
    
    data.forEach(row => {
        const name = row.Name ? row.Name.trim() : "";
        const id = row.Id ? row.Id.toString().trim() : "";
        const empid = row.Empid ? row.Empid.trim() : "";
        const remark = row.Remark ? row.Remark.trim() : "";
        
        // Skip employees with Remark = "No"
        if (remark.toLowerCase() === "no") {
            console.log(`Skipping employee ${name} (${empid}) - Remark is 'No'`);
            return;
        }
        
        if (!name || !id || !empid) return;
        
        const managerName = row["Reporting Manager"] ? row["Reporting Manager"].trim() : "-";
        let managerId = "-";
        
        // Try to find manager ID
        if (managerName !== "-" && managerName !== "") {
            const potentialManagers = nameToEmployees.get(managerName);
            
            if (potentialManagers && potentialManagers.length === 1) {
                // Only one person with this name - safe to use
                managerId = potentialManagers[0].id;
            } else if (potentialManagers && potentialManagers.length > 1) {
                // Multiple people with same name - log warning
                console.warn(`Multiple managers found with name "${managerName}" for employee ${name} (${empid}). Using first match.`);
                managerId = potentialManagers[0].id;
            } else {
                // Manager name not found
                console.warn(`Manager "${managerName}" not found for employee ${name} (${empid})`);
            }
        }
        
        employeeMap.set(id, {
            id: id,
            name: name,
            empid: empid,
            department: row["Department Name"] || "",
            designation: row.Designation || "",
            grade: row.Grade || "",
            location: row["Base Location"] || "",
            managerName: managerName,
            managerId: managerId,
            email: row.Email || "",
            mobile: row.Mobileno || "",
            doj: row.Doj || "",
            status: row.Employeestatus || "",
            children: []
        });
    });
    
    // Find top-level managers (those with "-" as manager OR in whitelist)
    const topManagers = [];
    const assignedEmployees = new Set();
    
    employeeMap.forEach((employee, id) => {
        // Check if employee is in whitelist OR has "-" as manager
        const isInWhitelist = TOP_LEVEL_WHITELIST.includes(employee.name);
        const hasNoManager = employee.managerId === "-" || employee.managerId === undefined;
        
        if (isInWhitelist || hasNoManager) {
            topManagers.push(employee);
            assignedEmployees.add(id);
            
            if (isInWhitelist) {
                console.log(`Adding ${employee.name} to top level (whitelist)`);
            }
        }
    });
    
    console.log("Top managers:", topManagers.length);
    
    // Build parent-child relationships using IDs
    employeeMap.forEach((employee, id) => {
        if (employee.managerId !== "-" && employee.managerId !== undefined) {
            // Skip if this employee is in the whitelist (already at top level)
            if (TOP_LEVEL_WHITELIST.includes(employee.name)) {
                return;
            }
            
            const manager = employeeMap.get(employee.managerId);
            if (manager) {
                manager.children.push(employee);
                assignedEmployees.add(id);
            } else {
                console.warn("Manager not found:", employee.managerName, "(ID lookup failed) for employee:", employee.name);
            }
        }
    });
    
    // Handle orphaned employees (those whose manager doesn't exist)
    const orphans = [];
    employeeMap.forEach((employee, id) => {
        if (!assignedEmployees.has(id)) {
            orphans.push(employee);
        }
    });
    
    if (orphans.length > 0) {
        console.warn("Orphaned employees (no valid manager):", orphans.length);
        console.warn("Orphaned employee names:", orphans.map(e => e.name));
    }
    
    console.log("Total employees processed:", employeeMap.size);
    console.log("Employees in hierarchy:", assignedEmployees.size);
    console.log("Missing from chart:", employeeMap.size - assignedEmployees.size);
    
    // Create virtual root
    const rootNode = {
        name: "Organization",
        isVirtual: true,
        children: topManagers
    };
    
    // Sort all children by grade recursively
    function sortChildrenByGrade(node) {
        if (node.children && node.children.length > 0) {
            // Helper function to count total descendants
            function countAllDescendants(emp) {
                if (!emp.children || emp.children.length === 0) return 0;
                let count = emp.children.length;
                emp.children.forEach(child => {
                    count += countAllDescendants(child);
                });
                return count;
            }
            
            // Sort children by grade order, then by descendant count
            node.children.sort((a, b) => {
                // Primary sort: by grade
                const gradeCompare = getGradeIndex(a.grade) - getGradeIndex(b.grade);
                if (gradeCompare !== 0) return gradeCompare;
                
                // Secondary sort: by descendant count (descending - higher count first)
                return countAllDescendants(b) - countAllDescendants(a);
            });
            
            // Recursively sort children's children
            node.children.forEach(child => sortChildrenByGrade(child));
        }
    }
    
    sortChildrenByGrade(rootNode);
    
    return rootNode;
}

// =======================================================
// UPDATE CHART
// =======================================================
function update(source) {
    // Compute the new tree layout
    const treeData = tree(root);
    const nodes = treeData.descendants().filter(d => !d.data.isVirtual);
    const links = treeData.links().filter(d => !d.target.data.isVirtual);
    
    // Update nodes
    const node = g.selectAll(".node")
        .data(nodes, d => d.data.name);
    
    // Enter new nodes
    const nodeEnter = node.enter().append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${source.x0 || 0},${source.y0 || 0})`)
        .on("click", (event, d) => {
            toggle(d);
            update(d);
        })
        .on("mousedown", function(event) {
            event.stopPropagation();
        });
    
    // 1. CARD BACKGROUND
    nodeEnter.append("rect")
        .attr("width", nodeWidth)
        .attr("height", nodeHeight)
        .attr("x", -nodeWidth / 2)
        .attr("y", -nodeHeight / 2)
        .style("fill", d => d._children ? "#fef3c7" : "#fff");
    
    // 2. NAME (Header)
    nodeEnter.append("text")
        .attr("class", "node-name")
        .attr("dy", -nodeHeight / 2 + 20)
        .attr("text-anchor", "middle")
        .text(d => d.data.name)
        .style("fill-opacity", 1e-6);
    
    // 3. SEPARATOR LINE
    nodeEnter.append("line")
        .attr("x1", -nodeWidth / 2 + 20)
        .attr("x2", nodeWidth / 2 - 20)
        .attr("y1", -nodeHeight / 2 + 35)
        .attr("y2", -nodeHeight / 2 + 35)
        .attr("stroke", "#e5e7eb")
        .attr("stroke-width", 1);

    // --- NEW 5-ITEM LIST (Adjusted Spacing) ---
    
    // Item 1: Empid
    // nodeEnter.append("text")
    //     .attr("class", "node-label")
    //     .attr("x", 0)
    //     .attr("y", -12)  // Moved up
    //     .attr("text-anchor", "middle")
    //     .style("font-size", "11px")
    //     .style("font-weight", "500")
    //     .style("fill", "#4b5563")
    //     .text(d => `${d.data.empid || "-"}`)
    //     .style("fill-opacity", 1e-6);

    // Item 2: Dept
    nodeEnter.append("text")
        .attr("class", "node-label")
        .attr("x", 0)
        .attr("y", -12)   // Moved up
        .attr("text-anchor", "middle")
        .style("font-size", "13px")
        .style("font-weight", "500")
        .style("fill", "#4b5563")
        .text(d => {
            const val = d.data.department || "-";
            return `${val.length > 28 ? val.substring(0, 28) + "..." : val}`;
        })
        .style("fill-opacity", 1e-6);

    // Item 3: Desig
    nodeEnter.append("text")
        .attr("class", "node-label")
        .attr("x", 0)
        .attr("y", 4)  // Moved up
        .attr("text-anchor", "middle")
        .style("font-size", "13px")
        .style("font-weight", "500")
        .style("fill", "#4b5563")
        .text(d => {
            const val = d.data.designation || "-";
            return `${val.length > 28 ? val.substring(0, 28) + "..." : val}`;
        })
        .style("fill-opacity", 1e-6)
        .append("title")
        .text(d => d.data.designation);

    // Item 4: Grade
    nodeEnter.append("text")
        .attr("class", "node-label")
        .attr("x", 0)
        .attr("y", 20)  // Moved up
        .attr("text-anchor", "middle")
        .style("font-size", "13px")
        .style("font-weight", "500")
        .style("fill", "#4b5563")
        .text(d => `Grade: ${d.data.grade || "-"}`)
        .style("fill-opacity", 1e-6);

    // Item 5: Location with icon
     nodeEnter.append("text")
        .attr("class", "node-label")
        .attr("x", 0)
        .attr("y", 36)  // Bottom slot
        .attr("text-anchor", "middle")
        .style("font-size", "13px")
        .style("font-weight", "500")
        .style("fill", "#4b5563")
        .text(d => `üìç ${d.data.location || "-"}`)
        .style("fill-opacity", 1e-6);

    // --- END LIST ---
    
    // Count badge logic
    const badgeGroup = nodeEnter.append("g")
        .attr("class", "badge-group")
        .attr("transform", `translate(${nodeWidth / 2 - 28}, ${-nodeHeight / 2 + 20})`)
        .style("opacity", d => d._children ? 1 : 0);
    
    badgeGroup.append("circle")
        .attr("class", "count-badge-bg")
        .attr("r", 15);
    
    badgeGroup.append("text")
        .attr("class", "count-badge")
        .attr("dy", "0.35em")
        .attr("text-anchor", "middle")
        .text(d => d._children ? `+${countDescendants(d)}` : "")
        .style("fill-opacity", 1e-6);
    
    // Transitions and updates
    const nodeUpdate = nodeEnter.merge(node);
    
    nodeUpdate.transition()
        .duration(750)
        .attr("transform", d => `translate(${d.x},${d.y})`);
    
    nodeUpdate.select("rect")
        .style("fill", d => d._children ? "#fef3c7" : "#fff")
        .style("stroke", d => d._children ? "#f59e0b" : "#667eea")
        .attr("class", d => d._children ? "collapsed" : "");
    
    nodeUpdate.selectAll("text").style("fill-opacity", 1);
    
    // Update location icon opacity
    nodeUpdate.selectAll(".location-group path").style("opacity", 1);
    
    nodeUpdate.select(".badge-group").style("opacity", d => d._children ? 1 : 0);
    nodeUpdate.select(".badge-group .count-badge").text(d => d._children ? `+${countDescendants(d)}` : "");
    
    const nodeExit = node.exit().transition()
        .duration(750)
        .attr("transform", d => `translate(${source.x},${source.y})`)
        .remove();
    
    nodeExit.select("rect").style("opacity", 1e-6);
    nodeExit.selectAll("text").style("fill-opacity", 1e-6);
    nodeExit.selectAll(".location-group path").style("opacity", 1e-6);
    
    // Update links
    const link = g.selectAll(".link").data(links, d => d.target.data.name);
    
    const linkEnter = link.enter().insert("path", "g")
        .attr("class", "link")
        .attr("d", d3.linkVertical()
            .x(d => source.x0 || 0)
            .y(d => source.y0 || 0));
    
    const linkUpdate = linkEnter.merge(link);
    
    linkUpdate.transition().duration(750).attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));
    
    link.exit().transition()
        .duration(750)
        .attr("d", d3.linkVertical().x(d => source.x).y(d => source.y))
        .remove();
    
    nodes.forEach(d => {
        d.x0 = d.x;
        d.y0 = d.y;
    });
}

// =======================================================
// HELPER FUNCTIONS
// =======================================================
function toggle(d) {
    if (d.children) {
        // When collapsing, also collapse all descendants
        function collapseAll(node) {
            if (node.children) {
                node._children = node.children;
                node._children.forEach(collapseAll);
                node.children = null;
            }
        }
        collapseAll(d);
    } else {
        // When expanding, just expand this level
        d.children = d._children;
        d._children = null;
    }
}

function collapse(d) {
    if (d.children) {
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
    }
}

function expand(d) {
    if (d._children) {
        d.children = d._children;
        d.children.forEach(expand);
        d._children = null;
    }
}

function countDescendants(d) {
    let count = 0;
    
    // Count both visible children and collapsed children
    const childArray = d._children || d.children;
    
    if (childArray) {
        count = childArray.length;
        childArray.forEach(child => {
            count += countDescendants(child);
        });
    }
    
    return count;
}

function expandAll() {
    expand(root);
    update(root);
}

function collapseAll() {
    // First collapse all children recursively
    if (root.children) {
        root.children.forEach(collapse);
    }
    // Then collapse the root itself to hide top-level employees
    collapse(root);
    update(root);
}

function resetZoom() {
    // Stop ALL ongoing transitions more aggressively
    svg.selectAll("*").interrupt();
    svg.interrupt();
    d3.selectAll("*").interrupt();
    
    // Center on root with scale 1.0 and shifted 10px upwards
    const scale = 1.0;
    const x = -root.x * scale + width / 2;
    const y = -root.y * scale + 40;  // Changed from 100 to 40 (60px upwards)
    
    // Apply transform with transition
    svg.transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
    
    d3.select("#chart").style("cursor", "grab");
}

function centerNode(source) {
    const scale = 0.8;
    const x = -source.x * scale + width / 2;
    const y = -source.y * scale + 100;
    
    svg.transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
}

// =======================================================
// TOOLTIP - REMOVED (Info now displayed on cards)
// =======================================================
// let hideTimeout;
// function showTooltip(event, d) { ... }
// function hideTooltip() { ... }

// =======================================================
// SEARCH FUNCTIONALITY
// =======================================================
function searchEmployee() {
    const searchTerm = document.getElementById('search-input').value.trim().toLowerCase();
    
    if (!searchTerm) {
        alert("Please enter a name to search");
        return;
    }
    
    // Remove previous highlights
    g.selectAll(".node").classed("highlighted", false);
    
    // Find the node with matching name (search through ALL nodes, including collapsed)
    let foundNode = null;
    
    function searchInNode(node) {
        if (node.data.name && node.data.name.toLowerCase().includes(searchTerm)) {
            foundNode = node;
            return true;
        }
        
        // Search in visible children
        if (node.children) {
            for (let child of node.children) {
                if (searchInNode(child)) return true;
            }
        }
        
        // Search in collapsed children
        if (node._children) {
            for (let child of node._children) {
                if (searchInNode(child)) return true;
            }
        }
        
        return false;
    }
    
    searchInNode(root);
    
    if (!foundNode) {
        alert(`No employee found with name: "${searchTerm}"`);
        return;
    }
    
    // Collapse all nodes recursively
    function collapseNode(d) {
        if (d.children) {
            d._children = d.children;
            d._children.forEach(collapseNode);
            d.children = null;
        }
    }
    
    // Collapse everything including root's children
    if (root.children) {
        root.children.forEach(collapseNode);
    }
    
    // Expand path from root to the found node (but NOT the found node itself)
    expandPathToNode(foundNode);
    
    // Update the tree
    update(root);
    
    // Center and zoom on the found node after a short delay to allow tree to render
    setTimeout(() => {
        centerAndHighlightNode(foundNode);
    }, 800);
}

function expandPathToNode(node) {
    // Build path from node to root (excluding the node itself)
    const path = [];
    let current = node.parent; // Start from parent, not the node itself
    
    while (current) {
        path.unshift(current);
        current = current.parent;
    }
    
    // Expand all nodes in the path (but not the searched node)
    path.forEach(d => {
        if (d._children) {
            d.children = d._children;
            d._children = null;
        }
    });
}

function centerAndHighlightNode(node) {
    // Center on the node
    const scale = 1;
    const x = -node.x * scale + width / 2;
    const y = -node.y * scale + height / 2;
    
    svg.transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
    
    // Highlight the node
    g.selectAll(".node")
        .filter(d => d === node)
        .classed("highlighted", true);
    
    // Remove highlight after 4 seconds
    setTimeout(() => {
        g.selectAll(".node").classed("highlighted", false);
    }, 4000);
}

// Add Enter key listener to search input
document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('search-input');
    if (searchInput) {
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchEmployee();
            }
        });
    }
});

// =======================================================
// KEYBOARD SHORTCUTS
// =======================================================
document.addEventListener('keydown', function(e) {
    // Don't trigger shortcuts if user is typing in input field
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
    }
    
    const key = e.key.toLowerCase();
    
    // Handle C and R shortcuts
    if (key === 'c') {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        collapseAll();
        return false;
    } else if (key === 'r') {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        resetZoom();
        return false;
    }
    
    // Handle arrow keys for panning
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
        e.preventDefault(); // Prevent default scrolling behavior
        
        // Get current transform
        const currentTransform = d3.zoomTransform(svg.node());
        
        // Define pan distance
        const panDistance = 30;
        
        // Calculate new translation based on arrow key
        let newX = currentTransform.x;
        let newY = currentTransform.y;
        
        switch(e.key) {
            case 'ArrowLeft':
                newX += panDistance;
                break;
            case 'ArrowRight':
                newX -= panDistance;
                break;
            case 'ArrowUp':
                newY += panDistance;
                break;
            case 'ArrowDown':
                newY -= panDistance;
                break;
        }
        
        // Apply the new transform
        svg.call(zoom.transform, d3.zoomIdentity
            .translate(newX, newY)
            .scale(currentTransform.k));
        return false;
    }
    
    // Handle + or - keys for zooming
    if (e.key === '+' || e.key === '=' || e.key === '-' || e.key === '_') {
        e.preventDefault(); // Prevent default browser zoom
        
        // Get current transform
        const currentTransform = d3.zoomTransform(svg.node());
        
        // Define zoom factor
        const zoomFactor = 1.2;
        let newScale = currentTransform.k;
        
        // Calculate new scale
        if (e.key === '+' || e.key === '=') {
            newScale = currentTransform.k * zoomFactor;
        } else if (e.key === '-' || e.key === '_') {
            newScale = currentTransform.k / zoomFactor;
        }
        
        // Clamp scale to reasonable limits
        newScale = Math.max(0.1, Math.min(3, newScale));
        
        // Calculate the zoom center (center of viewport)
        const centerX = width / 2;
        const centerY = height / 2;
        
        // Calculate new translation to zoom towards center
        const newX = centerX - (centerX - currentTransform.x) * (newScale / currentTransform.k);
        const newY = centerY - (centerY - currentTransform.y) * (newScale / currentTransform.k);
        
        // Apply the new transform with smooth transition
        svg.transition()
            .duration(300)
            .call(zoom.transform, d3.zoomIdentity
                .translate(newX, newY)
                .scale(newScale));
        return false;
    }
}, true);

// =======================================================
// PREVENT BROWSER ZOOM (Allow only D3 zoom on chart)
// =======================================================
document.addEventListener('gesturestart', function(e) {
    e.preventDefault();
});

document.addEventListener('gesturechange', function(e) {
    e.preventDefault();
});

document.addEventListener('gestureend', function(e) {
    e.preventDefault();
});

// Prevent ctrl/cmd + scroll zoom
document.addEventListener('wheel', function(e) {
    if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
    }
}, { passive: false });

// Prevent pinch zoom
document.addEventListener('touchmove', function(e) {
    if (e.touches.length > 1) {
        e.preventDefault();
    }
}, { passive: false });

// Prevent double-tap zoom on mobile
let lastTouchEnd = 0;
document.addEventListener('touchend', function(e) {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
        e.preventDefault();
    }
    lastTouchEnd = now;
}, false);

// =======================================================
// AUTO-REFRESH - REMOVED (Now using manual refresh button)
// =======================================================

// Initialize on load
initialize();

// Handle window resize
window.addEventListener('resize', function() {
    // Add resize handling if needed
});
</script>

</body>
</html>
